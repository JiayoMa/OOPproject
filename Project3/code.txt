#pragma once
#ifndef USERMANAGER_H
#define USERMANAGER_H

#include <vector>
#include <string>
#include <memory> // For std::unique_ptr
#include "User.h" 

class UserManager {
private:
    std::vector<std::unique_ptr<User>> users; // Store unique_ptrs to User
    std::string usersFilePath;
    std::vector<Device*>& allDevices;

    void loadUsersFromFile();
    void saveUsersToFile() const;

public:
    UserManager(const std::string& filePath, std::vector<Device*>& devices);
    // No explicit ~UserManager needed if unique_ptr handles memory

    // Return raw pointers (User*) for convenience, but ownership remains with unique_ptr
    User* registerUser(const std::string& username, const std::string& password, UserRole role = UserRole::USER);
    User* loginUser(const std::string& username, const std::string& password);

    bool deleteUser(const std::string& usernameToDelete, const User& adminUser);
    User* findUser(const std::string& username); // Returns raw pointer
};

#endif // USERMANAGER_H



#include "UserManager.h"
#include <fstream>
#include <sstream>
#include <iostream>   
#include <algorithm>  

// extern SmartLogger gLogger; 

UserManager::UserManager(const std::string& filePath, std::vector<Device*>& devices)
    : usersFilePath(filePath), allDevices(devices) {
    loadUsersFromFile();
    if (users.empty()) {
        std::cout << "User data not found. Creating default admin (admin/admin)..." << std::endl;
        registerUser("admin", "admin", UserRole::ADMIN);
    }
}

// Destructor is not strictly needed as unique_ptr will clean up, 
// but if you had other raw pointers to manage, you would add it.
// UserManager::~UserManager() {}

void UserManager::loadUsersFromFile() {
    std::ifstream inFile(usersFilePath);
    if (!inFile.is_open()) {
        return;
    }

    users.clear(); // Clear existing unique_ptrs, freeing memory
    std::string line;
    while (std::getline(inFile, line)) {
        std::stringstream ss(line);
        std::string username, passwordHash, roleStr;

        if (std::getline(ss, username, ':') &&
            std::getline(ss, passwordHash, ':') &&
            std::getline(ss, roleStr)) {
            // Create User on the heap and store in unique_ptr
            users.push_back(std::make_unique<User>(username, passwordHash, stringToRole(roleStr), allDevices));
        }
        else {
            // std::cerr << "Warning: Malformed line in user file: " << line << std::endl;
        }
    }
    inFile.close();
}

void UserManager::saveUsersToFile() const {
    std::ofstream outFile(usersFilePath);
    if (!outFile.is_open()) {
        std::cerr << "Error: Cannot open user file '" << usersFilePath << "' for writing." << std::endl;
        return;
    }

    for (const auto& user_ptr : users) { // Iterate over unique_ptrs
        if (user_ptr) { // Check if the pointer is not null
            outFile << user_ptr->getUsername() << ":"
                << user_ptr->getPassword() << ":"
                << roleToString(user_ptr->getRole()) << std::endl;
        }
    }
    outFile.close();
}

User* UserManager::registerUser(const std::string& username, const std::string& password, UserRole role) {
    if (username.empty() || password.empty()) {
        std::cout << "Username and password cannot be empty." << std::endl;
        return nullptr;
    }
    for (const auto& user_ptr : users) {
        if (user_ptr && user_ptr->getUsername() == username) {
            std::cout << "Username '" << username << "' already exists." << std::endl;
            return nullptr;
        }
    }

    users.push_back(std::make_unique<User>(username, password, role, allDevices));
    saveUsersToFile();
    std::cout << "User '" << username << "' registered successfully." << std::endl;
    return users.back().get(); // Return raw pointer from the new unique_ptr
}

User* UserManager::loginUser(const std::string& username, const std::string& password) {
    for (const auto& user_ptr : users) {
        if (user_ptr && user_ptr->getUsername() == username && user_ptr->getPassword() == password) {
            std::cout << "User '" << username << "' logged in successfully." << std::endl;
            return user_ptr.get(); // Return raw pointer
        }
    }
    std::cout << "Login failed: Invalid username or password." << std::endl;
    return nullptr;
}

bool UserManager::deleteUser(const std::string& usernameToDelete, const User& adminUser) {
    if (adminUser.getRole() != UserRole::ADMIN) {
        std::cout << "Permission denied. Only admins can delete users." << std::endl;
        return false;
    }

    if (adminUser.getUsername() == usernameToDelete) {
        std::cout << "Admin cannot delete themselves." << std::endl;
        return false;
    }

    auto it = std::remove_if(users.begin(), users.end(),
        [&](const std::unique_ptr<User>& u_ptr) {
            return u_ptr && u_ptr->getUsername() == usernameToDelete;
        });

    if (it != users.end()) {
        users.erase(it, users.end()); // This erases the unique_ptrs, deleting the User objects
        saveUsersToFile();
        std::cout << "User '" << usernameToDelete << "' has been deleted." << std::endl;
        return true;
    }
    else {
        std::cout << "User '" << usernameToDelete << "' not found." << std::endl;
        return false;
    }
}

User* UserManager::findUser(const std::string& username) {
    for (const auto& user_ptr : users) {
        if (user_ptr && user_ptr->getUsername() == username) {
            return user_ptr.get(); // Return raw pointer
        }
    }
    return nullptr;
}




#pragma once
#ifndef USER_H
#define USER_H

#include <string>
#include <vector>
#include "Device.h" 
#include "SmartLogger.h" 

// extern SmartLogger gLogger; // Only if gLogger is truly global and defined elsewhere

enum class UserRole {
    USER,
    ADMIN
};

// Helper functions for UserRole (can be in .cpp if preferred)
inline std::string roleToString(UserRole role) {
    switch (role) {
    case UserRole::ADMIN: return "ADMIN";
    case UserRole::USER: return "USER";
    default: return "USER"; // Should ideally not happen
    }
}

inline UserRole stringToRole(const std::string& roleStr) {
    if (roleStr == "ADMIN") return UserRole::ADMIN;
    return UserRole::USER;
}

class User {
private:
    std::string username;
    std::string password;
    UserRole role;
    std::vector<Device*>& devices;

public:
    User(const std::string& name, const std::string& pwd, UserRole r, std::vector<Device*>& deviceList);

    std::string getUsername() const;
    std::string getPassword() const;
    UserRole getRole() const;
    const std::vector<Device*>& getDevices() const; // If User needs to expose this

    void runTemperatureHumidityRule(double tempThreshold = 30.0, double humidityThreshold = 70.0);
    void runFireEmergencyRule(double co2FireThreshold = 0.06);
};

#endif // USER_H




#include "User.h"
#include "Sensor.h" // For dynamic_cast
#include "AC.h"     // For dynamic_cast
#include "Light.h"  // For dynamic_cast
#include <iostream> // For std::cout in demo methods

// extern SmartLogger gLogger; // If used directly

User::User(const std::string& name, const std::string& pwd, UserRole r, std::vector<Device*>& deviceList)
    : username(name), password(pwd), role(r), devices(deviceList) {
    // gLogger.INFO("User created: " + username);
}

std::string User::getUsername() const {
    return username;
}

std::string User::getPassword() const {
    return password;
}

UserRole User::getRole() const {
    return role;
}

const std::vector<Device*>& User::getDevices() const {
    return devices;
}

void User::runTemperatureHumidityRule(double tempThreshold, double humidityThreshold) {
    // Using std::cout directly, no "using std::cout;" as a member
    std::cout << username << " 正在进行温湿度检测..." << std::endl;
    for (Device* device : devices) {
        if (Sensor* sensor = dynamic_cast<Sensor*>(device)) {
            if (sensor->getTemperature() > tempThreshold || sensor->getHumidity() > humidityThreshold) {
                std::cout << "警报：传感器 " << sensor->getName()
                    << " 检测到温度为"<< sensor->getTemperature() <<"湿度为" << sensor->getHumidity() <<"温湿度超限！" << std::endl;
                for (Device* acDevice : devices) {
                    if (AC* ac = dynamic_cast<AC*>(acDevice)) {
                        if (ac->getMode() == ACMode::OFF || ac->getMode() == ACMode::HEAT) {
                            std::cout << "关闭空调 " << ac->getName()
                                << " 调为制冷模式" << std::endl;
                            ac->setMode(ACMode::COOL);
                            ac->setTargetTemperature(22.0);
                        }
                    }
                }
            }
        }
    }
}

void User::runFireEmergencyRule(double co2FireThreshold) {
    std::cout << username << " 正在进行火情检测..." << std::endl;
    for (Device* device : devices) {
        if (Sensor* sensor = dynamic_cast<Sensor*>(device)) {
            if (sensor->getCO2Concentration() > co2FireThreshold) {
                std::cout << "严重警报：传感器" << sensor->getName()
                    << " 检测到二氧化碳超标！有火情！" << std::endl;
                for (Device* devToShutdown : devices) {
                    if (Light* light = dynamic_cast<Light*>(devToShutdown)) {
                        light->turnOff();
                        std::cout << "关灯断电" << light->getName() << std::endl;
                    }
                    else if (AC* ac = dynamic_cast<AC*>(devToShutdown)) {
                        ac->setMode(ACMode::OFF);
                        std::cout << "关闭空调" << ac->getName() << std::endl;
                    }
                    if (devToShutdown->getImportance() != DeviceImportance::CRITICAL) {
                        // Assuming setEmergencyPowerOff exists and is appropriate here
                        // devToShutdown->setEmergencyPowerOff(true); 
                        std::cout << "紧急关机"
                            << devToShutdown->getName() << std::endl;
                    }
                }
            }
        }
    }
}




#pragma once // Use #pragma once or standard include guards
#ifndef SMARTLOGGER_H
#define SMARTLOGGER_H

#include <string>
#include <fstream>
#include <iostream>
#include <chrono>
#include <iomanip> // For std::put_time
#include <sstream> // For formatting time
#include <thread>  // For std::this_thread::get_id() later

enum class LogLevel {
    DEBUG,
    INFO,
    ALERT
};

// Abstract Logger class (Interface)
class LoggerStrategy {
public:
    virtual ~LoggerStrategy() = default;
    virtual void log(const std::string& message, LogLevel level, int deviceId = -1, std::thread::id threadId = std::this_thread::get_id()) = 0;
};

// Concrete Logger: Console
class ConsoleLogger : public LoggerStrategy {
public:
    void log(const std::string& message, LogLevel level, int deviceId = -1, std::thread::id threadId = std::this_thread::get_id()) override;
};

// Concrete Logger: File
class FileLogger : public LoggerStrategy {
private:
    std::ofstream logFile;
public:
    FileLogger(const std::string& filename);
    ~FileLogger() override;
    void log(const std::string& message, LogLevel level, int deviceId = -1, std::thread::id threadId = std::this_thread::get_id()) override;
};

// SmartLogger class (Context)
class SmartLogger {
private:
    LoggerStrategy* strategy; // Using a single strategy for now, can be a list for multiple outputs
    LogLevel minimumLevel;

    std::string levelToString(LogLevel level);
    std::string getCurrentTimestamp();

public:
    SmartLogger(LoggerStrategy* strategy, LogLevel minLevel = LogLevel::INFO);
    ~SmartLogger();

    void setStrategy(LoggerStrategy* newStrategy); // Allow changing strategy
    void setMinimumLevel(LogLevel level);

    void log(const std::string& message, LogLevel level, int deviceId = -1);

    // Simplified macro-like functions (true macros are preprocessor directives)
    void DEBUG(const std::string& message, int deviceId = -1);
    void INFO(const std::string& message, int deviceId = -1);
    void ALERT(const std::string& message, int deviceId = -1);
};

// Macro definitions (optional, but as requested)
// These would typically be outside the class, in the .h file
// For simplicity, we'll use member functions above that act like macros.
// True macros would look like:
// #define LOG_ALERT(logger_instance, msg, devId) logger_instance.log(msg, LogLevel::ALERT, devId)

#endif // SMARTLOGGER_H
#include "SmartLogger.h"

// --- Helper function to get current timestamp ---
std::string SmartLogger::getCurrentTimestamp() {
    auto now = std::chrono::system_clock::now();
    auto in_time_t = std::chrono::system_clock::to_time_t(now);
    std::stringstream ss;
    // ss << std::put_time(std::localtime(&in_time_t), "%Y-%m-%d %X"); // Using localtime

    // Using gmtime to avoid potential issues with std::localtime and thread-safety if used across threads later
    // However, std::gmtime also has thread-safety concerns with its static buffer on some platforms.
    // C++20 introduces thread-safe time formatting. For now, this is a common approach.
    std::tm timeinfo_tm;
#ifdef _WIN32
    gmtime_s(&timeinfo_tm, &in_time_t); // Windows specific
#else
    gmtime_r(&in_time_t, &timeinfo_tm); // POSIX specific
#endif
    ss << std::put_time(&timeinfo_tm, "%Y-%m-%d %H:%M:%S UTC");

    return ss.str();
}

std::string SmartLogger::levelToString(LogLevel level) {
    switch (level) {
    case LogLevel::DEBUG: return "DEBUG";
    case LogLevel::INFO:  return "INFO";
    case LogLevel::ALERT: return "ALERT";
    default: return "UNKNOWN";
    }
}

// --- ConsoleLogger Implementation ---
void ConsoleLogger::log(const std::string& message, LogLevel level, int deviceId, std::thread::id threadId) {
    // SmartLogger handles timestamp and level string, ConsoleLogger just prints
    std::cout << message << std::endl;
}

// --- FileLogger Implementation ---
FileLogger::FileLogger(const std::string& filename) {
    logFile.open(filename, std::ios::app); // Append mode
    if (!logFile.is_open()) {
        std::cerr << "    :  ޷     ־ ļ  '" << filename << "'" << std::endl;
    }
}

FileLogger::~FileLogger() {
    if (logFile.is_open()) {
        logFile.close();
    }
}

void FileLogger::log(const std::string& message, LogLevel level, int deviceId, std::thread::id threadId) {
    if (logFile.is_open()) {
        logFile << message << std::endl;
    }
}

// --- SmartLogger Implementation ---
SmartLogger::SmartLogger(LoggerStrategy* initialStrategy, LogLevel minLevel)
    : strategy(initialStrategy), minimumLevel(minLevel) {
}

SmartLogger::~SmartLogger() {
    delete strategy; // SmartLogger owns the strategy object passed to it
}

void SmartLogger::setStrategy(LoggerStrategy* newStrategy) {
    delete strategy; // Delete old strategy
    strategy = newStrategy;
}

void SmartLogger::setMinimumLevel(LogLevel level) {
    minimumLevel = level;
}

void SmartLogger::log(const std::string& message, LogLevel level, int deviceId) {
    if (level < minimumLevel) {
        return;
    }
    if (!strategy) {
        std::cerr << "    : SmartLoggerû             !" << std::endl;
        return;
    }

    std::stringstream formattedMessage;
    formattedMessage << "[" << getCurrentTimestamp() << "] ";
    formattedMessage << "[" << levelToString(level) << "] ";

    // Get thread ID (basic, more advanced might involve mapping to names)
    // std::stringstream tid_ss;
    // tid_ss << std::this_thread::get_id();
    // formattedMessage << "[Thread:" << tid_ss.str() << "] ";


    if (deviceId != -1) {
        formattedMessage << "[ 豸ID:" << deviceId << "] ";
    }
    formattedMessage << message;

    strategy->log(formattedMessage.str(), level, deviceId); // Pass all info to strategy if it needs it
}

void SmartLogger::DEBUG(const std::string& message, int deviceId) {
    log(message, LogLevel::DEBUG, deviceId);
}
void SmartLogger::INFO(const std::string& message, int deviceId) {
    log(message, LogLevel::INFO, deviceId);
}
void SmartLogger::ALERT(const std::string& message, int deviceId) {
    log(message, LogLevel::ALERT, deviceId);
}

#pragma once
#ifndef SENSOR_H
#define SENSOR_H

#include "Device.h"

class Sensor : public Device {
private:
    double temperature;     // Celsius
    double humidity;        // Percentage
    double co2Concentration; // ppm or percentage (as per your requirement, let's use percentage for fire detection)

public:
    Sensor(int id, const std::string& name, DeviceImportance importance, double powerConsumption,
           double temp = 20.0, double hum = 50.0, double co2 = 0.04); // 0.04% is typical atmospheric CO2

    ~Sensor() override;
    std::string toFileString() const override;
    void updateStatus() override;
    void displayInfo() const override;

    // Getters
    double getTemperature() const;
    double getHumidity() const;
    double getCO2Concentration() const;

    // Setters
    void setTemperature(double temp);
    void setHumidity(double hum);
    void setCO2Concentration(double co2);

    friend std::istream& operator>>(std::istream& is, Sensor& sensor);
};

#endif // SENSOR_H
#include "../include/Sensor.h"
#include <iostream> 
#include <sstream> 
Sensor::Sensor(int id, const std::string& name, DeviceImportance importance, double powerConsumption,
    double temp, double hum, double co2)
    : Device(id, name, importance, powerConsumption), temperature(temp), humidity(hum), co2Concentration(co2) {
}

Sensor::~Sensor() {
    // std::cout << "传感器 " << name << " (ID: " << id << ") 已销毁。" << std::endl;
}

void Sensor::updateStatus() {
    std::cout << "正在更新传感器 " << name << " (ID: " << id << ") 的状态:" << std::endl;
    temperature += (rand() % 3 - 1) * 0.1;
    humidity += (rand() % 5 - 2) * 0.5;
    co2Concentration += (rand() % 3 - 1) * 0.001;

    if (humidity < 0) humidity = 0;
    if (humidity > 100) humidity = 100;
    if (co2Concentration < 0) co2Concentration = 0;

    std::cout << "  新温度: " << temperature << " C" << std::endl;
    std::cout << "  新湿度: " << humidity << " %" << std::endl;
    std::cout << "  新CO2浓度: " << co2Concentration * 100 << " %" << std::endl;
}

void Sensor::displayInfo() const {
    Device::displayInfo();
    std::cout << ", 温度: " << temperature << " C"
        << ", 湿度: " << humidity << " %"
        << ", CO2浓度: " << co2Concentration * 100 << " %";
}

double Sensor::getTemperature() const { return temperature; }
double Sensor::getHumidity() const { return humidity; }
double Sensor::getCO2Concentration() const { return co2Concentration; }

void Sensor::setTemperature(double temp) { this->temperature = temp; }
void Sensor::setHumidity(double hum) { this->humidity = hum; }
void Sensor::setCO2Concentration(double co2) { this->co2Concentration = co2; }

std::istream& operator>>(std::istream& is, Sensor& sensor) {
    is >> static_cast<Device&>(sensor);
    std::cout << "请输入温度 (C): ";
    is >> sensor.temperature;
    std::cout << "请输入湿度 (%): ";
    is >> sensor.humidity;
    std::cout << "请输入CO2浓度 (例如, 0.06 代表 6%): ";
    is >> sensor.co2Concentration;
    return is;
}
std::string Sensor::toFileString() const {
    std::stringstream ss;
    ss << "Sensor," // 类型
        << Device::toFileString() // 调用基类获取通用部分: id,name,importance,powerConsumption
        << "," << getTemperature()
        << "," << getHumidity()
        << "," << getCO2Concentration();
    return ss.str();
}
#include <iostream>
#include <vector>
#include <string>
#include <limits>
#include <algorithm>
#include <fstream> // Required for file operations
#include <sstream> // Required for parsing lines
#include <cctype>  // For std::tolower

// 包含您的类头文件
#include "Device.h"
#include "Sensor.h"
#include "Light.h"
#include "AC.h"
#include "DeviceFactory.h"
#include "User.h"        // 确保 User 类已定义
#include "UserManager.h" // 引入 UserManager
#include "SmartLogger.h" // Include for SmartLogger, FileLogger, LogLevel definitions

// --- 全局工厂实例 ---
SensorFactory sensorFactory;
LightFactory lightFactory;
ACFactory acFactory;

// --- 全局设备列表 ---
std::vector<Device*> allDevices; // 主设备列表

// --- 当前登录用户 (修改为指针) ---
User* currentUser = nullptr;

// --- 日志记录器实例 (如果需要全局使用) ---
// SmartLogger gLogger(new FileLogger("smart_home_log_cn.txt"), LogLevel::INFO);




// --- HELPER FUNCTION to convert string to ACMode ---
ACMode stringToACMode(const std::string& s) {
    try {
        int val = std::stoi(s);
        if (val >= 0 && val <= 3) return static_cast<ACMode>(val); // Assuming 0-OFF, 1-COOL, 2-HEAT, 3-FAN
        std::cerr << "警告: 未知的空调模式值 '" << s << "'。默认为关闭。" << std::endl;
    }
    catch (const std::exception& e) {
        std::cerr << "警告: 解析空调模式值 '" << s << "' 失败: " << e.what() << "。默认为关闭。" << std::endl;
    }
    return ACMode::OFF; // Default
}
std::string acModeToString(ACMode mode) {
    return std::to_string(static_cast<int>(mode));
}

// --- HELPER FUNCTION to convert string to FanSpeed ---
FanSpeed stringToFanSpeed(const std::string& s) {
    try {
        int val = std::stoi(s);
        if (val >= 0 && val <= 3) return static_cast<FanSpeed>(val); // Assuming 0-LOW, 1-MEDIUM, 2-HIGH, 3-AUTO
        std::cerr << "警告: 未知的风扇速度值 '" << s << "'。默认为自动。" << std::endl;
    }
    catch (const std::exception& e) {
        std::cerr << "警告: 解析风扇速度值 '" << s << "' 失败: " << e.what() << "。默认为自动。" << std::endl;
    }
    return FanSpeed::AUTO; // Default
}
std::string fanSpeedToString(FanSpeed speed) {
    return std::to_string(static_cast<int>(speed));
}


// --- 文件导入/导出函数 (保持您原来的逻辑，稍作调整以使用 allDevices) ---
void importDevicesFromFile(std::vector<Device*>& devices_vec, const std::string& filename = "devices_cn.txt") { // 使用中文文件名
    std::ifstream inFile(filename);
    if (!inFile.is_open()) {
        std::cerr << "错误: 无法打开设备文件 '" << filename << "' 进行读取。" << std::endl;
        std::cerr << "文件格式应为: TYPE,ID,Name,Importance(0-3),PowerConsumption,emergencyPowerOff(0/1),[specific_params...]" << std::endl;
        return;
    }

    std::string line;
    int lineNumber = 0;
    while (std::getline(inFile, line)) {
        lineNumber++;
        if (line.empty() || line[0] == '#') continue;

        std::stringstream ss(line);
        std::string segment;
        std::vector<std::string> segments;
        while (std::getline(ss, segment, ',')) {
            segments.push_back(segment);
        }

        if (segments.size() < 6) { // TYPE,ID,Name,Importance,PowerConsumption,emergencyPowerOff
            std::cerr << "警告: 文件第 " << lineNumber << " 行参数不足，跳过: " << line << std::endl;
            continue;
        }

        std::string typeStr = segments[0];
        try {
            DeviceParams params;
            params.id = std::stoi(segments[1]);

            bool id_exists = false;
            for (const auto& dev : devices_vec) { // 检查 devices_vec
                if (dev->getId() == params.id) {
                    id_exists = true;
                    break;
                }
            }
            if (id_exists) {
                std::cerr << "警告: 设备ID " << params.id << " (来自文件第 " << lineNumber << " 行) 已存在，跳过导入。" << std::endl;
                continue;
            }

            params.name = segments[2];
            params.importance = stringToImportance(segments[3]);
            params.powerConsumption = std::stod(segments[4]);
            bool emergencyOff = (segments[5] == "1");


            Device* newDevice = nullptr;
            // 注意类型字符串比较，您的原始代码可能是大写 "SENSOR"
            if ((typeStr == "SENSOR" || typeStr == "Sensor") && segments.size() >= 9) {
                params.temperature = std::stod(segments[6]);
                params.humidity = std::stod(segments[7]);
                params.co2Concentration = std::stod(segments[8]);
                newDevice = sensorFactory.createDeviceWithParams(params);
            }
            else if ((typeStr == "LIGHT" || typeStr == "Light") && segments.size() >= 8) {
                params.isOn = (segments[6] == "1");
                params.brightness = std::stoi(segments[7]);
                newDevice = lightFactory.createDeviceWithParams(params);
            }
            else if ((typeStr == "AC" || typeStr == "ac") && segments.size() >= 9) {
                params.acMode = stringToACMode(segments[6]);
                params.targetTemperature = std::stod(segments[7]);
                params.fanSpeed = stringToFanSpeed(segments[8]);
                newDevice = acFactory.createDeviceWithParams(params);
            }
            else {
                std::cerr << "警告: 文件第 " << lineNumber << " 行设备类型 '" << typeStr << "' 无法识别或参数不足: " << line << std::endl;
                continue;
            }

            if (newDevice) {
                newDevice->setEmergencyPowerOff(emergencyOff);
                devices_vec.push_back(newDevice); // 添加到 devices_vec
            }
        }
        catch (const std::invalid_argument& e) {
            std::cerr << "错误: 解析文件第 " << lineNumber << " 行时发生无效参数错误 '" << line << "': " << e.what() << std::endl;
        }
        catch (const std::out_of_range& e) {
            std::cerr << "错误: 解析文件第 " << lineNumber << " 行时发生越界错误 '" << line << "': " << e.what() << std::endl;
        }
        catch (const std::exception& e) {
            std::cerr << "错误: 解析文件第 " << lineNumber << " 行时发生未知错误 '" << line << "': " << e.what() << std::endl;
        }
    }
    inFile.close();
    std::cout << "设备已从 '" << filename << "' 导入完毕。" << std::endl;
}

void saveDevicesToFile(const std::vector<Device*>& devices_vec, const std::string& filename = "devices_cn.txt") { // 使用中文文件名
    std::ofstream outFile(filename);
    if (!outFile.is_open()) {
        std::cerr << "错误: 无法打开设备文件 '" << filename << "' 进行写入。" << std::endl;
        return;
    }

    outFile << "# TYPE,ID,Name,Importance(0-3),PowerConsumption,emergencyPowerOff(0/1),[specific_params...]\n";
    outFile << "# SENSOR,ID,Name,Imp,PC,EPO,temperature,humidity,co2Concentration\n"; // 统一类型大写
    outFile << "# LIGHT,ID,Name,Imp,PC,EPO,isOn(0/1),brightness\n";
    outFile << "# AC,ID,Name,Imp,PC,EPO,mode(0-3),targetTemperature,fanSpeed(0-3)\n";

    for (const auto& device : devices_vec) { // 使用 devices_vec
        std::string typeStr;
        std::string specificParamsStr;

        if (const Sensor* sensor = dynamic_cast<const Sensor*>(device)) {
            typeStr = "SENSOR"; // 保存为大写
            std::stringstream ss;
            ss << "," << sensor->getTemperature()
                << "," << sensor->getHumidity()
                << "," << sensor->getCO2Concentration();
            specificParamsStr = ss.str();
        }
        else if (const Light* light = dynamic_cast<const Light*>(device)) {
            typeStr = "LIGHT"; // 保存为大写
            std::stringstream ss;
            ss << "," << (light->getIsOn() ? "1" : "0")
                << "," << light->getBrightness();
            specificParamsStr = ss.str();
        }
        else if (const AC* ac = dynamic_cast<const AC*>(device)) {
            typeStr = "AC"; // 保存为大写
            std::stringstream ss;
            ss << "," << acModeToString(ac->getMode())
                << "," << ac->getTargetTemperature()
                << "," << fanSpeedToString(ac->getFanSpeed());
            specificParamsStr = ss.str();
        }
        else {
            std::cerr << "警告: 保存时遇到未知设备类型 (ID: " << device->getId() << ")，跳过。" << std::endl;
            continue;
        }

        outFile << typeStr << ","
            << device->getId() << ","
            << device->getName() << ","
            << importanceToString(device->getImportance()) << ","
            << device->getPowerConsumption() << ","
            << (device->isEmergencyPowerOff() ? "1" : "0")
            << specificParamsStr << std::endl;
    }
    outFile.close();
    std::cout << "所有设备信息已保存至 '" << filename << "'。" << std::endl;
}

// --- 用户相关功能 ---
void initializeAndPrintUser() {
    std::cout << "\n--- 当前用户信息 ---" << std::endl;
    if (currentUser) {
        std::cout << "当前登录用户: " << currentUser->getUsername() << std::endl;
        std::cout << "用户角色: " << roleToString(currentUser->getRole()) << std::endl;
        // 可以添加更多用户信息打印
    }
    else {
        std::cout << "当前没有用户登录。" << std::endl;
    }
}

// 初始认证和登录/注册流程
bool initialAuthAndLogin(UserManager& userManager, User*& targetUser, std::vector<Device*>& devices_ref) {
    while (targetUser == nullptr) {
        std::cout << "\n=========== 用户认证 ===========\n";
        std::cout << "1. 用户登录\n";
        std::cout << "2. 注册新用户\n";
        std::cout << "3. 退出系统\n";
        std::cout << "============================\n";
        std::cout << "请选择: ";
        char authChoice_char;
        std::cin >> authChoice_char;
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // 清除换行符

        std::string username, password;
        switch (authChoice_char) {
        case '1':
            std::cout << "请输入用户名: ";
            std::getline(std::cin, username);
            std::cout << "请输入密码: ";
            std::getline(std::cin, password);
            targetUser = userManager.loginUser(username, password);
            if (targetUser) {
                std::cout << "用户 '" << targetUser->getUsername() << "' 登录成功！" << std::endl;
                return true;
            }
            else {
                std::cout << "登录失败，用户名或密码错误。" << std::endl;
            }
            break;
        case '2':
            std::cout << "--- 注册新用户 ---" << std::endl;
            std::cout << "请输入新用户名: ";
            std::getline(std::cin, username);
            std::cout << "请输入密码: ";
            std::getline(std::cin, password);
            // 默认注册为普通用户，可以根据需要扩展角色选择
            targetUser = userManager.registerUser(username, password, UserRole::USER);
            if (targetUser) {
                std::cout << "用户 '" << targetUser->getUsername() << "' 注册并登录成功！" << std::endl;
                return true;
            }
            else {
                // registerUser 应该在失败时打印具体原因 (例如用户名已存在)
                // std::cout << "注册失败。" << std::endl; // UserManager.registerUser 内部应处理错误信息
            }
            break;
        case '3':
            std::cout << "您选择了退出系统。" << std::endl;
            return false; // 用户选择退出程序
        default:
            std::cout << "无效选择，请重新输入。" << std::endl;
            break;
        }
    }
    return false; // 理论上循环会处理，但为编译器满意
}


// --- 设备查找和删除 (保持您原来的逻辑) ---
void findDeviceById(const std::vector<Device*>& devices_vec) { // 使用 devices_vec
    if (devices_vec.empty()) {
        std::cout << "设备列表为空，无法查找。" << std::endl;
        return;
    }
    std::cout << "请输入要查找的设备ID: ";
    int id;
    std::cin >> id;
    if (std::cin.fail()) {
        std::cout << "输入ID无效。" << std::endl;
        std::cin.clear();
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        return;
    }
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

    bool found = false;
    for (const auto& device : devices_vec) {
        if (device->getId() == id) {
            std::cout << "找到设备:" << std::endl;
            // 假设 Device 类重载了 << 操作符或有 displayInfo()
            device->displayInfo(); // 或者 std::cout << *device << std::endl;
            found = true;
            break;
        }
    }
    if (!found) {
        std::cout << "未找到ID为 " << id << " 的设备。" << std::endl;
    }
}

void deleteDeviceById(std::vector<Device*>& devices_vec) { // 使用 devices_vec
    if (devices_vec.empty()) {
        std::cout << "设备列表为空，无法删除。" << std::endl;
        return;
    }
    std::cout << "请输入要删除的设备ID: ";
    int id;
    std::cin >> id;
    if (std::cin.fail()) {
        std::cout << "输入ID无效。" << std::endl;
        std::cin.clear();
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        return;
    }
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

    bool deleted = false;
    auto it = devices_vec.begin();
    while (it != devices_vec.end()) {
        if ((*it)->getId() == id) {
            std::cout << "确认删除设备: ";
            (*it)->displayInfo();
            std::cout << " (y/n): ";
            char confirm_char;
            std::cin >> confirm_char;
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
            if (tolower(confirm_char) == 'y') {
                delete* it; // 释放内存
                it = devices_vec.erase(it); // 从 vector 中移除并获取下一个有效迭代器
                deleted = true;
                std::cout << "ID为 " << id << " 的设备已删除。" << std::endl;
                // 由于ID应该是唯一的，找到一个就可以停止了
                break;
            }
            else {
                std::cout << "删除操作已取消。" << std::endl;
                // 如果不删除，则继续检查下一个（尽管ID应该是唯一的）
                ++it;
            }
        }
        else {
            ++it;
        }
    }

    if (!deleted) { // 如果循环结束都没删除（即没找到或用户取消）
        bool found_but_not_confirmed_delete = false; // 检查是否是找到但用户没确认
        for (const auto& dev : devices_vec) { if (dev->getId() == id) found_but_not_confirmed_delete = true; }
        if (!found_but_not_confirmed_delete) {
            std::cout << "未找到ID为 " << id << " 的设备，无法删除。" << std::endl;
        }
    }
}

// --- 场景模拟 (保持您原来的逻辑，确保 User 类有相应方法) ---
void simulateSmartScenes(User& user, std::vector<Device*>& devices_ref) { // 参数使用 devices_ref
    std::cout << "\n--- 智能场景模拟 ---" << std::endl;
    std::cout << "1. 模拟温湿度超限 (空调启动)" << std::endl;
    std::cout << "2. 模拟火灾检测 (CO2超标，尝试关闭电器)" << std::endl;
    std::cout << "请选择要模拟的场景: ";
    int sceneChoice;
    std::cin >> sceneChoice;
    if (std::cin.fail()) {
        std::cout << "无效输入。" << std::endl;
        std::cin.clear();
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        return;
    }
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

    if (sceneChoice == 1) {
        user.runTemperatureHumidityRule(); // User类需要实现此方法
        std::cout << "\n场景模拟: 温湿度超限规则执行完毕。" << std::endl;
    }
    else if (sceneChoice == 2) {
        user.runFireEmergencyRule(); // User类需要实现此方法
        std::cout << "\n场景模拟: 火灾检测规则执行完毕。" << std::endl;
    }
    else {
        std::cout << "无效的场景选择。" << std::endl;
    }
}

// --- 主菜单打印 ---
void printMainMenu() {
    std::cout << "\n=========== 主菜单 ===========\n";
    if (currentUser) {
        std::cout << "当前用户: " << currentUser->getUsername()
            << " (角色: " << roleToString(currentUser->getRole()) << ")\n";
    }
    else {
        std::cout << "当前无用户登录\n";
    }
    std::cout << "----------------------------\n";
    std::cout << "0 ---- 切换用户/注册新用户\n"; // 修改了选项0的含义
    std::cout << "1 ---- 打印当前用户信息\n";   // 原来的 "初始化并打印当前用户"
    std::cout << "2 ---- 从文件导入设备\n";
    std::cout << "3 ---- 从键盘添加设备\n";
    std::cout << "4 ---- 列表显示当前所有设备\n";
    std::cout << "5 ---- 按指定ID查找设备\n";
    std::cout << "6 ---- 删除指定ID的设备\n";
    std::cout << "7 ---- 保存所有设备信息至文件中\n";
    std::cout << "8 ---- 智能场景模拟\n";
    std::cout << "Q ---- 退出\n";
    std::cout << "============================\n";
    std::cout << "请选择: ";
}


int main() {
    std::cout << "智能家居控制系统启动中..." << std::endl;

    // 创建 UserManager 实例，它会尝试加载用户数据
    UserManager userManager("users_cn.txt", allDevices); // users_cn.txt 是用户数据文件

    // 初始用户认证
    if (!initialAuthAndLogin(userManager, currentUser, allDevices)) {
        std::cout << "未能完成用户认证，系统即将退出。" << std::endl;
        // 清理设备资源
        for (Device* device : allDevices) {
            delete device;
        }
        allDevices.clear();
        return 0; // 用户选择在认证阶段退出
    }

    // 如果认证成功，currentUser 会被设置
    // 导入设备（可以在用户登录后进行，或者作为系统初始化的一部分）
    // importDevicesFromFile(allDevices, "devices_cn.txt"); // 移到认证后或按需调用

    char choice_char;
    do {
        printMainMenu();
        std::cin >> choice_char;
        // 清理输入缓冲区，特别是对于混合使用 std::cin >> char 和 std::getline 的情况
        if (std::cin.peek() == '\n') { // 检查下一个字符是否是换行符
            std::cin.ignore();
        }
        else if (std::cin.fail() || std::cin.eof()) { // 处理错误或EOF
            std::cin.clear(); // 清除错误标志
            // 可以选择忽略到行尾，或者如果确定只读了一个字符，则不需要额外ignore
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        }


        char lower_choice = std::tolower(choice_char);

        if (lower_choice == 'q') {
            std::cout << "正在保存设备信息并退出智能家居系统。再见!" << std::endl;
            saveDevicesToFile(allDevices, "devices_cn.txt");
            break;
        }

        int choice_int = -1;
        if (lower_choice >= '0' && lower_choice <= '8') { // 选项0现在有效
            choice_int = lower_choice - '0';
        }
        else {
            std::cout << "无效的选择。请输入菜单中的数字或 'Q' 退出。" << std::endl;
            continue;
        }

        switch (choice_int) {
        case 0: // 切换用户/注册新用户
            if (currentUser) {
                std::cout << "用户 '" << currentUser->getUsername() << "' 已注销。" << std::endl;
                // 注意：如果User对象是UserManager管理的，这里不应该delete currentUser
                // UserManager应该负责User对象的生命周期。这里仅将指针置空。
                currentUser = nullptr;
            }
            if (!initialAuthAndLogin(userManager, currentUser, allDevices)) {
                std::cout << "未能完成用户认证，系统即将退出。" << std::endl;
                saveDevicesToFile(allDevices, "devices_cn.txt"); // 退出前保存
                // 清理并退出
                for (Device* device : allDevices) { delete device; } allDevices.clear();
                return 0;
            }
            break;
        case 1:
            initializeAndPrintUser();
            break;
        case 2:
            importDevicesFromFile(allDevices, "devices_cn.txt");
            break;
        case 3: { // 从键盘添加设备 (保持您原来的逻辑)
            std::cout << "\n--- 从键盘添加设备 ---\n";
            std::cout << "选择设备类型 (1: 传感器, 2: 灯具, 3: 空调): ";
            int typeChoice;
            std::cin >> typeChoice;

            if (std::cin.fail() || typeChoice < 1 || typeChoice > 3) {
                std::cout << "无效的设备类型选择。" << std::endl;
                std::cin.clear();
                std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
                continue;
            }
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

            Device* newDevice = nullptr;
            DeviceParams currentParams; // 来自 DeviceFactory.h

            std::cout << "请输入设备ID (整数): ";
            std::cin >> currentParams.id;
            if (std::cin.fail()) {
                std::cout << "ID输入无效。" << std::endl;
                std::cin.clear();
                std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
                continue;
            }
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

            bool id_exists = false;
            for (const auto& dev : allDevices) {
                if (dev->getId() == currentParams.id) {
                    id_exists = true;
                    break;
                }
            }
            if (id_exists) {
                std::cout << "错误：设备ID " << currentParams.id << " 已存在。请使用唯一的ID。" << std::endl;
                continue;
            }

            std::cout << "请输入设备名称: ";
            std::getline(std::cin, currentParams.name);
            if (currentParams.name.empty()) currentParams.name = "未命名设备";

            std::cout << "请输入重要程度 (0:低, 1:中, 2:高, 3:危急): ";
            int impChoice_int;
            std::cin >> impChoice_int;
            currentParams.importance = stringToImportance(std::to_string(impChoice_int));

            std::cout << "请输入能耗 (瓦特): ";
            std::cin >> currentParams.powerConsumption;
            if (std::cin.fail()) { /* 错误处理 */ std::cout << "能耗输入无效。" << std::endl; std::cin.clear(); std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); continue; }


            // emergencyPowerOff 可以在这里设置，或者由Device构造函数处理默认值
            // std::cout << "是否启用紧急断电? (1 是, 0 否): ";
            // int emergencyOffChoice; std::cin >> emergencyOffChoice;
            // bool emergencyOff = (emergencyOffChoice == 1);


            try {
                if (typeChoice == 1) { // Sensor
                    std::cout << "请输入初始温度 (C): "; std::cin >> currentParams.temperature;
                    std::cout << "请输入初始湿度 (%): "; std::cin >> currentParams.humidity;
                    std::cout << "请输入初始CO2浓度 (ppm, 例如 400): "; std::cin >> currentParams.co2Concentration;
                    if (std::cin.fail()) { throw std::runtime_error("传感器参数输入无效。"); }
                    newDevice = sensorFactory.createDeviceWithParams(currentParams);
                }
                else if (typeChoice == 2) { // Light
                    std::cout << "灯具是否初始开启? (1 是, 0 否): "; int onState; std::cin >> onState;
                    currentParams.isOn = (onState == 1);
                    if (currentParams.isOn) {
                        std::cout << "请输入初始亮度 (0-100%): "; std::cin >> currentParams.brightness;
                    }
                    else {
                        currentParams.brightness = 0; // 如果关闭，亮度为0
                    }
                    if (std::cin.fail()) { throw std::runtime_error("灯具参数输入无效。"); }
                    newDevice = lightFactory.createDeviceWithParams(currentParams);
                }
                else if (typeChoice == 3) { // AC
                    int modeChoice_int, fanChoice_int;
                    std::cout << "请输入空调模式 (0:关闭, 1:制冷, 2:制热, 3:送风): "; std::cin >> modeChoice_int;
                    currentParams.acMode = static_cast<ACMode>(modeChoice_int); // 假设枚举值对应
                    if (currentParams.acMode != ACMode::OFF) {
                        std::cout << "请输入目标温度 (C): "; std::cin >> currentParams.targetTemperature;
                        std::cout << "请输入风速 (0:低, 1:中, 2:高, 3:自动): "; std::cin >> fanChoice_int;
                        currentParams.fanSpeed = static_cast<FanSpeed>(fanChoice_int); // 假设枚举值对应
                    }
                    else {
                        currentParams.targetTemperature = 25; // 默认关闭时的目标温度
                        currentParams.fanSpeed = FanSpeed::AUTO; // 默认关闭时的风速
                    }
                    if (std::cin.fail()) { throw std::runtime_error("空调参数输入无效。"); }
                    newDevice = acFactory.createDeviceWithParams(currentParams);
                }

                if (newDevice) {
                    // newDevice->setEmergencyPowerOff(emergencyOff); // 如果之前收集了此参数
                    allDevices.push_back(newDevice);
                    std::cout << "设备 '" << newDevice->getName() << "' (ID: " << newDevice->getId() << ") 创建成功。" << std::endl;
                }
            }
            catch (const std::exception& e) {
                std::cerr << "创建设备时发生错误: " << e.what() << std::endl;
                if (newDevice) { delete newDevice; newDevice = nullptr; }
                // 清理 cin 状态以防后续输入问题
                if (std::cin.fail()) {
                    std::cin.clear();
                    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
                }
            }
            // 确保在 switch case 块的末尾或循环的下一次迭代之前，任何未被 getline 清理的换行符都被处理
            if (std::cin.peek() == '\n') std::cin.ignore();
            break; // 从 case 3 退出
        }
        case 4: {
            std::cout << "\n--- 当前所有设备列表 ---\n";
            if (allDevices.empty()) {
                std::cout << "尚未创建或导入任何设备。" << std::endl;
            }
            else {
                for (const auto& device : allDevices) {
                    if (device) device->displayInfo(); // 假设 displayInfo 接受 ostream
                    // 或者: std::cout << *device << std::endl; // 如果重载了 <<
                }
            }
            break;
        }
        case 5:
            if (!currentUser) { std::cout << "请先登录用户。" << std::endl; break; }
            findDeviceById(allDevices);
            break;
        case 6:
            if (!currentUser) { std::cout << "请先登录用户。" << std::endl; break; }
            deleteDeviceById(allDevices);
            break;
        case 7:
            if (!currentUser) { std::cout << "请先登录用户。" << std::endl; break; }
            saveDevicesToFile(allDevices, "devices_cn.txt");
            break;
        case 8:
            if (!currentUser) {
                std::cout << "请先登录用户才能模拟场景。" << std::endl;
            }
            else {
                simulateSmartScenes(*currentUser, allDevices);
            }
            break;
        }
        // 在循环末尾添加一个暂停，以便用户可以看到输出
        if (lower_choice != 'q') {
            std::cout << "\n按任意键返回主菜单...";
            std::cin.get(); // 等待用户按键
            if (std::cin.peek() == '\n') std::cin.ignore(); // 清理可能的额外换行
        }

    } while (true);

    // 清理资源
    for (Device* device : allDevices) {
        delete device;
    }
    allDevices.clear();

    // 如果 currentUser 是由 UserManager new 出来的，UserManager 应负责 delete
    // 如果 UserManager 只是返回指向内部 User 对象的指针，则不需要在这里 delete currentUser
    // 假设 UserManager 管理 User 对象的生命周期，或者 User 对象是栈上的（但这里 currentUser 是指针）
    // 如果 UserManager::loginUser/registerUser 返回的是 new 出来的 User*，则需要 UserManager 提供清理方法或在此 delete
    // 为简单起见，这里假设 UserManager 不直接 new User* 给外部管理，或者有其他机制。
    // 如果 currentUser 指向的对象需要手动删除，且不由 UserManager 管理：
    // delete currentUser; 
    // currentUser = nullptr;

    std::cout << "智能家居系统已关闭。" << std::endl;
    return 0;
}
#pragma once
#ifndef LIGHT_H
#define LIGHT_H

#include "Device.h"

class Light : public Device {
private:
    bool isOn;
    int brightness; // Percentage 0-100

public:
    Light(int id, const std::string& name, DeviceImportance importance, double powerConsumption,
          bool on = false, int bright = 50);

    ~Light() override;

    void updateStatus() override;
    void displayInfo() const override;

    // Light specific methods
    void turnOn();
    void turnOff();
    void setBrightness(int level);

    // Getters
    bool getIsOn() const;
    int getBrightness() const;

    friend std::istream& operator>>(std::istream& is, Light& light);
};

#endif // LIGHT_H
#include "../include/Light.h"
#include <iostream> 

Light::Light(int id, const std::string& name, DeviceImportance importance, double powerConsumption,
    bool on, int bright)
    : Device(id, name, importance, powerConsumption), isOn(on), brightness(bright) {
}

Light::~Light() {
    // std::cout << "灯具 " << name << " (ID: " << id << ") 已销毁。" << std::endl;
}

void Light::updateStatus() {
    std::cout << "正在更新灯具 " << name << " (ID: " << id << ") 的状态:" << std::endl;
    std::cout << "  当前状态: " << (isOn ? "开" : "关") << std::endl;
    if (isOn) {
        std::cout << "  亮度: " << brightness << "%" << std::endl;
    }
}

void Light::displayInfo() const {
    Device::displayInfo();
    std::cout << ", 状态: " << (isOn ? "开" : "关");
    if (isOn) {
        std::cout << ", 亮度: " << brightness << "%";
    }
}

void Light::turnOn() {
    isOn = true;
    std::cout << name << " (ID: " << id << ") 已开启。" << std::endl;
}

void Light::turnOff() {
    isOn = false;
    std::cout << name << " (ID: " << id << ") 已关闭。" << std::endl;
}

void Light::setBrightness(int level) {
    if (level >= 0 && level <= 100) {
        brightness = level;
        std::cout << name << " (ID: " << id << ") 亮度已设置为 " << brightness << "%。" << std::endl;
        if (brightness > 0 && !isOn) {
            turnOn();
        }
        else if (brightness == 0 && isOn) {
            turnOff();
        }
    }
    else {
        std::cout << "无效的亮度级别。必须在0到100之间。" << std::endl;
    }
}

bool Light::getIsOn() const { return isOn; }
int Light::getBrightness() const { return brightness; }

std::istream& operator>>(std::istream& is, Light& light) {
    is >> static_cast<Device&>(light);
    std::cout << "灯是否开启? (1 代表是, 0 代表否): ";
    int onState;
    is >> onState;
    light.isOn = (onState == 1);
    if (light.isOn) {
        std::cout << "请输入亮度 (0-100%): ";
        is >> light.brightness;
        if (light.brightness < 0) light.brightness = 0;
        if (light.brightness > 100) light.brightness = 100;
    }
    else {
        light.brightness = 0;
    }
    return is;
}
#include "DeviceFactory.h" // This includes Sensor.h, Light.h, AC.h via Device.h if structured well, or include them directly
#include <iostream>

// --- SensorFactory Implementation ---
Device* SensorFactory::createDevice() {
    // Create a default Sensor, perhaps using DeviceParams default constructor
    DeviceParams defaultParams;
    return new Sensor(defaultParams.id, defaultParams.name, defaultParams.importance, defaultParams.powerConsumption,
                      defaultParams.temperature, defaultParams.humidity, defaultParams.co2Concentration);
}

Device* SensorFactory::createDeviceWithParams(const DeviceParams& params) {
    // Directly use the members of the params struct
    return new Sensor(params.id, params.name, params.importance, params.powerConsumption,
                      params.temperature, params.humidity, params.co2Concentration);
}

// --- LightFactory Implementation ---
Device* LightFactory::createDevice() {
    DeviceParams defaultParams;
    return new Light(defaultParams.id, defaultParams.name, defaultParams.importance, defaultParams.powerConsumption,
                     defaultParams.isOn, defaultParams.brightness);
}

Device* LightFactory::createDeviceWithParams(const DeviceParams& params) {
    return new Light(params.id, params.name, params.importance, params.powerConsumption,
                     params.isOn, params.brightness);
}

// --- ACFactory Implementation ---
Device* ACFactory::createDevice() {
    DeviceParams defaultParams;
    return new AC(defaultParams.id, defaultParams.name, defaultParams.importance, defaultParams.powerConsumption,
                  defaultParams.acMode, defaultParams.targetTemperature, defaultParams.fanSpeed);
}

Device* ACFactory::createDeviceWithParams(const DeviceParams& params) {
    return new AC(params.id, params.name, params.importance, params.powerConsumption,
                  params.acMode, params.targetTemperature, params.fanSpeed);
}
#pragma once
#ifndef DEVICE_H
#define DEVICE_H

#include <string>
#include <iostream>
#include <vector> // For params in factory

// Forward declaration for DeviceFactory to avoid circular dependency
class DeviceFactory;

// Enum for device types, useful for factories and containers
enum class DeviceType {
    SENSOR,
    LIGHT,
    AC
};

// Enum for device importance (example)
enum class DeviceImportance {
    LOW,
    MEDIUM,
    HIGH,
    CRITICAL
};
std::string importanceToString(DeviceImportance imp);
class Device {
protected:
    int id;
    std::string name;
    DeviceImportance importance;
    double powerConsumption; // Assuming kWh or similar unit
    bool emergencyPowerOff; // For emergency scenarios

public:
    // Constructor
    Device(int id, const std::string& name, DeviceImportance importance, double powerConsumption);

    // Virtual destructor
    virtual ~Device();
    virtual std::string toFileString() const; // 基类实现通用部分
    // Pure virtual function for status update (to be implemented by derived classes)
    virtual void updateStatus() = 0;

    // Getters
    int getId() const;
    std::string getName() const;
    DeviceImportance getImportance() const;
    double getPowerConsumption() const;
    bool isEmergencyPowerOff() const;

    // Setters
    void setId(int id);
    void setName(const std::string& name);
    void setImportance(DeviceImportance importance);
    void setPowerConsumption(double consumption);
    void setEmergencyPowerOff(bool status);


    // Virtual function to display device info, can be overridden
    virtual void displayInfo() const;

    // Friend function for overloading output operator
    friend std::ostream& operator<<(std::ostream& os, const Device& device);
    // Friend function for overloading input operator (basic example)
    friend std::istream& operator>>(std::istream& is, Device& device);
};
DeviceImportance stringToImportance(const std::string& s);
#endif // DEVICE_H
#include "../include/Device.h"
#include <iostream> // Make sure iostream is included if not alreadypowerConsumption
#include <sstream> //
Device::Device(int id, const std::string& name, DeviceImportance importance, double powerConsumption)
    : id(id), name(name), importance(importance), powerConsumption(powerConsumption), emergencyPowerOff(false) {
}
// 这就是 importanceToString 辅助函数
std::string importanceToString(DeviceImportance imp) { // 用于保存文件
    return std::to_string(static_cast<int>(imp)); // 将枚举值转换为其底层的整数，再转换为字符串
}
std::string Device::toFileString() const {
    std::stringstream ss;
    // 注意：类型字符串 (Sensor, Light, AC) 需要在子类中添加，或者在 saveDevicesToFile 中通过 dynamic_cast 判断
    // 这里只处理通用部分，不包含类型字符串和前导逗号
    ss << getId() << ","
        << getName() << ","
        << importanceToString(getImportance()) << "," // 需要 importanceToString 辅助函数
        << getPowerConsumption(); // 假设功耗可以直接输出
    return ss.str();
}
Device::~Device() {
    // std::cout << "设备 " << name << " (ID: " << id << ") 已销毁。" << std::endl;
}

int Device::getId() const { return id; }
std::string Device::getName() const { return name; }
DeviceImportance Device::getImportance() const { return importance; }
double Device::getPowerConsumption() const { return powerConsumption; }
bool Device::isEmergencyPowerOff() const { return emergencyPowerOff; }

void Device::setId(int id) { this->id = id; }
void Device::setName(const std::string& name) { this->name = name; }
void Device::setImportance(DeviceImportance importance) { this->importance = importance; }
void Device::setPowerConsumption(double consumption) { this->powerConsumption = consumption; }
void Device::setEmergencyPowerOff(bool status) { this->emergencyPowerOff = status; }


void Device::displayInfo() const {
    std::cout << "设备ID: " << id << ", 名称: " << name
        << ", 重要程度: ";
    switch (importance) {
    case DeviceImportance::LOW: std::cout << "低"; break;
    case DeviceImportance::MEDIUM: std::cout << "中"; break;
    case DeviceImportance::HIGH: std::cout << "高"; break;
    case DeviceImportance::CRITICAL: std::cout << "危急"; break;
    }
    std::cout << ", 能耗: " << powerConsumption << " 单位"
        << ", 紧急断电: " << (emergencyPowerOff ? "是" : "否");
}

std::ostream& operator<<(std::ostream& os, const Device& device) {
    device.displayInfo();
    return os;
}

std::istream& operator>>(std::istream& is, Device& device) {
    std::cout << "请输入设备ID: ";
    is >> device.id;
    std::cout << "请输入设备名称: ";
    is.ignore();
    std::getline(is, device.name);
    std::cout << "请输入能耗 (单位): ";
    is >> device.powerConsumption;
    // 重要程度通常通过菜单或特定逻辑设置，此处简化
    return is;
}
DeviceImportance stringToImportance(const std::string& s) {
    try {
        int val = std::stoi(s);
        if (val >= static_cast<int>(DeviceImportance::LOW) && val <= static_cast<int>(DeviceImportance::CRITICAL)) {
            return static_cast<DeviceImportance>(val);
        }
        std::cerr << "警告: 重要性值 '" << s << "' 超出预期范围。默认为 中。" << std::endl;
    }
    catch (const std::exception& e) {
        std::cerr << "警告: 重要性值 '" << s << "' 无效。默认为 中。错误: " << e.what() << std::endl;
    }
    return DeviceImportance::MEDIUM;
}

#pragma once
#ifndef AC_H
#define AC_H

#include "Device.h"

enum class ACMode {
    COOL,
    HEAT,
    FAN,
    OFF
};

enum class FanSpeed {
    LOW,
    MEDIUM,
    HIGH,
    AUTO
};

class AC : public Device {
private:
    ACMode mode;
    double targetTemperature; // Celsius
    FanSpeed fanSpeed;

public:
    AC(int id, const std::string& name, DeviceImportance importance, double powerConsumption,
       ACMode mode = ACMode::OFF, double temp = 22.0, FanSpeed speed = FanSpeed::AUTO);

    ~AC() override;

    void updateStatus() override;
    void displayInfo() const override;

    // AC specific methods
    void setMode(ACMode m);
    void setTargetTemperature(double temp);
    void setFanSpeed(FanSpeed speed);

    // Getters
    ACMode getMode() const;
    double getTargetTemperature() const;
    FanSpeed getFanSpeed() const;

    friend std::istream& operator>>(std::istream& is, AC& ac);
};

#endif // AC_H
#pragma once
#ifndef AC_H
#define AC_H

#include "Device.h"

enum class ACMode {
    COOL,
    HEAT,
    FAN,
    OFF
};

enum class FanSpeed {
    LOW,
    MEDIUM,
    HIGH,
    AUTO
};

class AC : public Device {
private:
    ACMode mode;
    double targetTemperature; // Celsius
    FanSpeed fanSpeed;

public:
    AC(int id, const std::string& name, DeviceImportance importance, double powerConsumption,
       ACMode mode = ACMode::OFF, double temp = 22.0, FanSpeed speed = FanSpeed::AUTO);

    ~AC() override;

    void updateStatus() override;
    void displayInfo() const override;

    // AC specific methods
    void setMode(ACMode m);
    void setTargetTemperature(double temp);
    void setFanSpeed(FanSpeed speed);

    // Getters
    ACMode getMode() const;
    double getTargetTemperature() const;
    FanSpeed getFanSpeed() const;

    friend std::istream& operator>>(std::istream& is, AC& ac);
};

#endif 
#include <iostream> 

AC::AC(int id, const std::string& name, DeviceImportance importance, double powerConsumption,
    ACMode mode, double temp, FanSpeed speed)
    : Device(id, name, importance, powerConsumption), mode(mode), targetTemperature(temp), fanSpeed(speed) {
}

AC::~AC() {
    
}

void AC::updateStatus() {
    std::cout << "   ڸ  ¿յ  " << name << " (ID: " << id << ")   ״̬:" << std::endl;
    std::cout << "    ǰģʽ: ";
    switch (mode) {
    case ACMode::COOL: std::cout << "    "; break;
    case ACMode::HEAT: std::cout << "    "; break;
    case ACMode::FAN: std::cout << " ͷ "; break;
    case ACMode::OFF: std::cout << " ر "; break;
    }
    std::cout << std::endl;
    if (mode != ACMode::OFF) {
        std::cout << "  Ŀ   ¶ : " << targetTemperature << " C" << std::endl;
        std::cout << "      : ";
        switch (fanSpeed) {
        case FanSpeed::LOW: std::cout << "  "; break;
        case FanSpeed::MEDIUM: std::cout << "  "; break;
        case FanSpeed::HIGH: std::cout << "  "; break;
        case FanSpeed::AUTO: std::cout << " Զ "; break;
        }
        std::cout << std::endl;
    }
}

void AC::displayInfo() const {
    Device::displayInfo();
    std::cout << ", ģʽ: ";
    switch (mode) {
    case ACMode::COOL: std::cout << "    "; break;
    case ACMode::HEAT: std::cout << "    "; break;
    case ACMode::FAN: std::cout << " ͷ "; break;
    case ACMode::OFF: std::cout << " ر "; break;
    }
    if (mode != ACMode::OFF) {
        std::cout << ", Ŀ   ¶ : " << targetTemperature << " C"
            << ",     : ";
        switch (fanSpeed) {
        case FanSpeed::LOW: std::cout << "  "; break;
        case FanSpeed::MEDIUM: std::cout << "  "; break;
        case FanSpeed::HIGH: std::cout << "  "; break;
        case FanSpeed::AUTO: std::cout << " Զ "; break;
        }
    }
}

void AC::setMode(ACMode m) {
    mode = m;
    std::cout << name << " (ID: " << id << ") ģʽ      Ϊ ";
    switch (mode) {
    case ACMode::COOL: std::cout << "    "; break;
    case ACMode::HEAT: std::cout << "    "; break;
    case ACMode::FAN: std::cout << " ͷ "; break;
    case ACMode::OFF: std::cout << " ر "; break;
    }
    std::cout << "  " << std::endl;
}

void AC::setTargetTemperature(double temp) {
    targetTemperature = temp;
    std::cout << name << " (ID: " << id << ") Ŀ   ¶       Ϊ " << targetTemperature << " C  " << std::endl;
}

void AC::setFanSpeed(FanSpeed speed) {
    fanSpeed = speed;
    std::cout << name << " (ID: " << id << ")           Ϊ ";
    switch (fanSpeed) {
    case FanSpeed::LOW: std::cout << "  "; break;
    case FanSpeed::MEDIUM: std::cout << "  "; break;
    case FanSpeed::HIGH: std::cout << "  "; break;
    case FanSpeed::AUTO: std::cout << " Զ "; break;
    }
    std::cout << "  " << std::endl;
}

ACMode AC::getMode() const { return mode; }
double AC::getTargetTemperature() const { return targetTemperature; }
FanSpeed AC::getFanSpeed() const { return fanSpeed; }

std::istream& operator>>(std::istream& is, AC& ac) {
    is >> static_cast<Device&>(ac);
    int modeChoice, fanChoice;
    std::cout << "      յ ģʽ (0: ر , 1:    , 2:    , 3: ͷ ): ";
    is >> modeChoice;
    ac.mode = static_cast<ACMode>(modeChoice);

    if (ac.mode != ACMode::OFF) {
        std::cout << "      Ŀ   ¶  (C): ";
        is >> ac.targetTemperature;
        std::cout << "          (0:  , 1:  , 2:  , 3: Զ ): ";
        is >> fanChoice;
        ac.fanSpeed = static_cast<FanSpeed>(fanChoice);
    }
    return is;
}